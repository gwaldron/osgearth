/* -*-c++-*- */
/* osgEarth - Dynamic map generation toolkit for OpenSceneGraph
 * Copyright 2008-2012 Pelican Mapping
 * http://osgearth.org
 *
 * osgEarth is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 */

#ifndef OSGEARTH_MATH_H
#define OSGEARTH_MATH_H 1

#include <osgEarth/Common>
#include <osgEarth/Geometry>
#include <osg/Quat>
#include <osg/Vec3>
#include <osg/BoundingBox>
#include <osg/Array>
#include <osg/Geometry>

namespace osgEarth
{
    struct Line2d;
    struct Segment2d;
    struct Ray2d;
    struct Segment3d;

    /** Infinite 2D line. */
    struct OSGEARTH_EXPORT Line2d
    {
        osg::Vec3d _a, _b; // two points on the line (Z ignored)
        Line2d() { }
        Line2d(const osg::Vec3d& a, const osg::Vec3d& b) : _a(a), _b(b) { }
        Line2d(const osg::Vec2d& a, const osg::Vec2d& b) : _a(a.x(), a.y(), 0), _b(b.x(), b.y(), 0) { }
        Line2d(const osg::Vec4d& a, const osg::Vec4d& b) : _a(a.x()/a.w(), a.y()/a.w(), a.z()/a.w()), _b(b.x()/b.w(), b.y()/b.w(), b.z()/b.w()) { }
        Line2d(const Line2d& rhs) : _a(rhs._a), _b(rhs._b) { }
        bool intersect( const Line2d&    rhs, osg::Vec2d& out ) const;
        bool intersect( const Ray2d&     rhs, osg::Vec2d& out ) const;
        bool intersect( const Segment2d& rhs, osg::Vec2d& out ) const;
        bool intersect( const Line2d&    rhs, osg::Vec3d& out ) const;
        bool intersect( const Ray2d&     rhs, osg::Vec3d& out ) const;
        bool intersect( const Segment2d& rhs, osg::Vec3d& out ) const;
        bool intersect( const Line2d&    rhs, osg::Vec4d& out ) const;
        bool isPointOnLeft( const osg::Vec2d& p ) const;
        bool isPointOnLeft( const osg::Vec3d& p ) const;
    };
    
    //// rotate a Line
    //inline Line2d operator* (const osg::Quat& q, const Line2d& rhs) {
    //    return Line( q * rhs._a, q * rhs._b );
    //}

    /** Endpoint and a direction vector */
    struct OSGEARTH_EXPORT Ray2d
    {
        osg::Vec3d _a;  // endpoint
        osg::Vec3d _dv; // directional vector
        Ray2d() { }
        Ray2d(const osg::Vec3d& a, const osg::Vec3d& dv) : _a(a), _dv(dv) { }
        Ray2d(const osg::Vec2d& a, const osg::Vec2d& dv) : _a(a.x(), a.y(), 0), _dv(dv.x(), dv.y(), 0) { }
        Ray2d(const Ray2d& rhs) : _a(rhs._a), _dv(rhs._dv) { }
        bool intersect( const Line2d&    rhs, osg::Vec2d& out ) const;
        bool intersect( const Ray2d&     rhs, osg::Vec2d& out ) const;
        bool intersect( const Segment2d& rhs, osg::Vec2d& out ) const;
        bool intersect( const Line2d&    rhs, osg::Vec3d& out ) const;
        bool intersect( const Ray2d&     rhs, osg::Vec3d& out ) const;
        bool intersect( const Segment2d& rhs, osg::Vec3d& out ) const;
        bool isPointOnLeft( const osg::Vec2d& p ) const;
        bool isPointOnLeft( const osg::Vec3d& p ) const;
        double angle(const Segment2d& rhs) const;
    };
    
    //// rotate a Ray
    //inline Ray operator* (const osg::Quat& q, const Ray& rhs) {
    //    return Ray( q * rhs._a, q * rhs._dv );
    //}

    /** Finite line between two endpoints */
    struct OSGEARTH_EXPORT Segment2d
    {
        osg::Vec3d _a, _b; // endpoints
        Segment2d() { }
        Segment2d(const osg::Vec3d& a, const osg::Vec3d& b) : _a(a), _b(b) { }
        Segment2d(const Segment2d& rhs) : _a(rhs._a), _b(rhs._b) { }
        bool intersect( const Line2d&    rhs, osg::Vec2d& out ) const;
        bool intersect( const Ray2d&     rhs, osg::Vec2d& out ) const;
        bool intersect( const Segment2d& rhs, osg::Vec2d& out ) const;
        bool intersect( const Line2d&    rhs, osg::Vec3d& out ) const;
        bool intersect( const Ray2d&     rhs, osg::Vec3d& out ) const;
        bool intersect( const Segment2d& rhs, osg::Vec3d& out ) const;
        bool isPointOnLeft( const osg::Vec2d& p ) const;
        bool isPointOnLeft( const osg::Vec3d& p ) const;
        Segment3d unrotateTo3D(const osg::Quat& q) const;
        double angle(const Segment2d& rhs) const;
        // Distance of point to segment; left side is positive
        double leftDistanceXY( const osg::Vec3d&p ) const
        {
            osg::Vec2d base(_b.x() - _a.x(), _b.y() - _a.y());
            // 2D cross product, 2 * area of triangle
            double cross = base.x() * (p.y() - _a.y()) - base.y() * (p.x() - _a.x());
            return cross / base.length();
        }
    };

    struct OSGEARTH_EXPORT Segment3d
    {
        osg::Vec3d _a, _b; // endpoints
        Segment3d() { }
        Segment3d(const osg::Vec3d& a, const osg::Vec3d& b) : _a(a), _b(b) { }
        Segment3d(const Segment3d& rhs) : _a(rhs._a), _b(rhs._b) { }
        Segment3d(const Segment2d& seg2d, const osg::Vec3& planeNormal);
        Segment2d rotateTo2D(const osg::Quat& q) { return Segment2d(q*_a, q*_b); }
    };
    
    //// rotate a Segment
    //inline Segment operator* (const osg::Quat& q, const Segment& rhs) {
    //    return Segment( q * rhs._a, q * rhs._b );
    //}

    /** 2D traingle with CCW winding. */
    struct OSGEARTH_EXPORT Triangle2d
    {
        osg::Vec3d _a, _b, _c;
        Triangle2d(const osg::Vec3d& a, const osg::Vec3d& b, const osg::Vec3d& c) : _a(a), _b(b), _c(c) { }
        bool contains(const osg::Vec3d& p) const;
    };

    // Work in progress. We want to use Ray without doing the work to
    // fully support the other types.

    struct Line;
    struct Ray;

#if 0
    /** Infinite 3D line. */
    struct Line
    {
        osg::Vec3d _a, _b; // two points on the line
        Line(const osg::Vec3d& a, const osg::Vec3d& b) : _a(a), _b(b) { }
        Line(const Line& rhs) : _a(rhs._a), _b(rhs._b) { }
        bool intersectXY( const Line&    rhs, osg::Vec3d& out ) const;
        bool intersectXY( const Ray&     rhs, osg::Vec3d& out ) const;
        bool intersectXY( const Segment& rhs, osg::Vec3d& out ) const;
    };
    
    // rotate a Line
    inline Line operator* (const osg::Quat& q, const Line& rhs) {
        return Line( q * rhs._a, q * rhs._b );
    }
#endif

    /** Endpoint and a direction vector */
    struct Ray
    {
        osg::Vec3d _a;  // endpoint
        osg::Vec3d _dv; // directional vector
        Ray(const osg::Vec3d& a, const osg::Vec3d& dv) : _a(a), _dv(dv) { }
        Ray(const Ray& rhs) : _a(rhs._a), _dv(rhs._dv) { }
#if 0
        bool intersectXY( const Line&    rhs, osg::Vec3d& out ) const;
        bool intersectXY( const Ray&     rhs, osg::Vec3d& out ) const;
        bool intersectXY( const Segment& rhs, osg::Vec3d& out ) const;
        bool isPointOnLeftXY( const osg::Vec3d& p ) const;
#endif
    };
    
    // rotate a Ray
    inline Ray operator* (const osg::Quat& q, const Ray& rhs) {
        return Ray( q * rhs._a, q * rhs._dv );
    }

#if 0
    /** Finite line between two endpoints */
    // This will need a new name before it's enabled; conflicts with a
    // type in osgEarth/Geometry.
    struct Segment
    {
        osg::Vec3d _a, _b; // endpoints
        Segment(const osg::Vec3d& a, const osg::Vec3d& b) : _a(a), _b(b) { }
        Segment(const Segment& rhs) : _a(rhs._a), _b(rhs._b) { }
        bool intersectXY( const Line&    rhs, osg::Vec3d& out ) const;
        bool intersectXY( const Ray&     rhs, osg::Vec3d& out ) const;
        bool intersectXY( const Segment& rhs, osg::Vec3d& out ) const;
        bool isPointOnLeftXY( const osg::Vec3d& p ) const;
    };
    
    // rotate a Segment
    inline Segment operator* (const osg::Quat& q, const Segment& rhs) {
        return Segment( q * rhs._a, q * rhs._b );
    }
#endif

    // Utility functions for arrays of points treated as a 2d polygon
    OSGEARTH_EXPORT osg::BoundingBoxd polygonBBox2d(const osg::Vec3dArray& points);
    OSGEARTH_EXPORT bool pointInPoly2d(const osg::Vec3d& pt, const Polygon& polyPoints,
                                       double tolerance = 0.0);
    OSGEARTH_EXPORT bool pointInPoly2d(const osg::Vec3d& pt, const osg::Geometry* polyPoints,
                                       float tolerance = 0.0f);
    template<class T>
    const T& clamp(const T& v, const T& lo, const T& hi)
    {
        if (v < lo)
        {
            return lo;
        }
        else if (v > hi)
        {
            return hi;
        }
        else
        {
            return v;
        }
    }

    // Newton-Raphson solver
    template<typename Func, typename FuncDeriv>
    double solve(Func func, FuncDeriv deriv, double guess, double tolerance, bool& valid, int maxIterations = 16)
    {
        double xn = guess;
        for (int i = 0; i <= maxIterations; ++i)
        {
            double f = func(xn);
            if (fabs(f) <= tolerance)
            {
                valid = true;
                return xn;
            }
            xn = xn - f / deriv(xn);
        }
        valid = false;
        return xn;
    }

    // Project osg::Vec3 a onto b.
    template<typename VecType>
    VecType vecProjection(const VecType& a, const VecType& b)
    {
        return b * ((a * b) / (b * b));
    }

    // Project osg::Vec3 a onto the plane perpendicular to b.
    template<typename VecType>
    VecType vecRejection(const VecType& a, const VecType& b)
    {
        return a - vecProjection(a, b);
    }
}
#endif
