/* -*-c++-*- */
/* osgEarth - Dynamic map generation toolkit for OpenSceneGraph
* Copyright 2008-2014 Pelican Mapping
* http://osgearth.org
*
* osgEarth is free software; you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>
*/
#ifndef OSGEARTH_ANNO_REGISTRY_H
#define OSGEARTH_ANNO_REGISTRY_H 1

#include <osgEarthAnnotation/AnnotationNode>
#include <osgEarth/MapNode>

namespace osgEarth { namespace Annotation
{
    /**
     * Singleton registry for annotation node types.
     */
    class OSGEARTHANNO_EXPORT AnnotationRegistry
    {
    public:
        /**
         * Access the singleton instance of this class.
         */
        static AnnotationRegistry* instance();

        /**
         * Creates one or more AnnotationNodes from a Config. The resulting
         * AnnotationNode's are placed under the provided group.
         */
        bool create( 
            MapNode*              mapNode, 
            const Config&         conf, 
            const osgDB::Options* dbOptions,
            osg::Group*&          output ) const;

        /**
         * Returns a Config containing all the AnnotationNode's found in the
         * specified subgraph. You can pass this Config to create(...) to 
         * rematerialize the nodes.
         */
        Config getConfig( osg::Node* graph ) const;

    public:
        /**
         * Adds an annotation type to the registry
         */
        void add( const std::string& key, class AnnotationFactory* factory );

        virtual ~AnnotationRegistry() { }

    private:
        AnnotationRegistry() { }
        typedef std::map<std::string, class AnnotationFactory*> FactoryMap;
        FactoryMap _factories;

        AnnotationNode* createOne( 
            MapNode*              mapNode, 
            const Config&         conf,
            const osgDB::Options* dbOptions, 
            bool                  declutter =false ) const;
    };

    // Macro used to register new annotation types.
#define OSGEARTH_REGISTER_ANNOTATION( KEY, CLASSNAME ) \
    static AnnotationRegistrationProxy< CLASSNAME > s_osgEarthAnnotationRegistrationProxy##KEY( #KEY )


    //--------------------------------------------------------------------

    // internal: interface class for an object that creates annotation node from a Config
    // (used by OSGEARTH_REGISTER_ANNOTATION macro)
    class AnnotationFactory {
    public:
        virtual AnnotationNode* create(
            MapNode*              mapNode, 
            const Config&         conf, 
            const osgDB::Options* dbOptions) const =0;

        virtual ~AnnotationFactory() { }
    };

    // internal: proxy class used by the registraion macro
    template<typename T>
    struct AnnotationRegistrationProxy : public AnnotationFactory {
        AnnotationRegistrationProxy(const std::string& key) { AnnotationRegistry::instance()->add(key, this); }
        AnnotationNode* create(MapNode* mapNode, const Config& conf, const osgDB::Options* options) const { return new T(mapNode, conf, options); }
    };

} } // namespace osgEarth::Annotation

#endif // OSGEARTH_ANNO_FEATURE_NODE_H
